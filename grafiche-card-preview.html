<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grafiche Card Preview - 3D Wireframe Eye</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Share Tech Mono', monospace;
    }

    .container {
      width: 600px;
      height: 400px;
      background: #000;
      border: 2px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="canvas"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    const dpr = 3;
    const width = 600;
    const height = 400;

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.scale(dpr, dpr);

    const state = {
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0,
      time: 0,
      palettePhase: 0,
      gridPhase: 0
    };

    function createEyeMesh() {
      const vertices = [];
      const edges = [];

      const eyeSegments = 24;
      const eyeRadiusX = 80;
      const eyeRadiusY = 40;

      for (let i = 0; i < eyeSegments; i++) {
        const angle = (i / eyeSegments) * Math.PI * 2;
        const x = Math.cos(angle) * eyeRadiusX;
        const y = Math.sin(angle) * eyeRadiusY;
        const z = Math.sin(angle * 2) * 10;
        vertices.push([x, y, z]);
        edges.push([i, (i + 1) % eyeSegments]);
      }

      const irisSegments = 16;
      const irisRadius = 25;
      const irisStartIdx = vertices.length;

      for (let i = 0; i < irisSegments; i++) {
        const angle = (i / irisSegments) * Math.PI * 2;
        const x = Math.cos(angle) * irisRadius;
        const y = Math.sin(angle) * irisRadius;
        const z = 5;
        vertices.push([x, y, z]);
        edges.push([irisStartIdx + i, irisStartIdx + (i + 1) % irisSegments]);
      }

      const pupilSegments = 12;
      const pupilRadius = 10;
      const pupilStartIdx = vertices.length;

      for (let i = 0; i < pupilSegments; i++) {
        const angle = (i / pupilSegments) * Math.PI * 2;
        const x = Math.cos(angle) * pupilRadius;
        const y = Math.sin(angle) * pupilRadius;
        const z = 8;
        vertices.push([x, y, z]);
        edges.push([pupilStartIdx + i, pupilStartIdx + (i + 1) % pupilSegments]);
      }

      for (let i = 0; i < 8; i++) {
        const eyeIdx = Math.floor((i / 8) * eyeSegments);
        const irisIdx = irisStartIdx + Math.floor((i / 8) * irisSegments);
        edges.push([eyeIdx, irisIdx]);
      }

      for (let i = 0; i < 6; i++) {
        const irisIdx = irisStartIdx + Math.floor((i / 6) * irisSegments);
        const pupilIdx = pupilStartIdx + Math.floor((i / 6) * pupilSegments);
        edges.push([irisIdx, pupilIdx]);
      }

      return { vertices, edges };
    }

    const eyeMesh = createEyeMesh();

    function rotateX(point, angle) {
      const [x, y, z] = point;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return [x, y * cos - z * sin, y * sin + z * cos];
    }

    function rotateY(point, angle) {
      const [x, y, z] = point;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return [x * cos + z * sin, y, -x * sin + z * cos];
    }

    function rotateZ(point, angle) {
      const [x, y, z] = point;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return [x * cos - y * sin, x * sin + y * cos, z];
    }

    function project(point, centerX, centerY) {
      const [x, y, z] = point;
      const scale = 200 / (200 + z);
      return [centerX + x * scale, centerY + y * scale, z];
    }

    function drawHexGrid() {
      const hexSize = 30;
      const hexHeight = hexSize * Math.sqrt(3);
      ctx.strokeStyle = `rgba(0, 255, 255, ${0.06 + Math.sin(state.gridPhase) * 0.02})`;
      ctx.lineWidth = 1;

      for (let row = -1; row < 15; row++) {
        for (let col = -1; col < 22; col++) {
          const x = col * hexSize * 1.5;
          const y = row * hexHeight + (col % 2) * hexHeight / 2;
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const px = x + Math.cos(angle) * hexSize;
            const py = y + Math.sin(angle) * hexSize;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.stroke();
        }
      }
    }

    function drawWireframeEye() {
      const centerX = 300;
      const centerY = 140;

      const rotatedVertices = eyeMesh.vertices.map(v => {
        let point = rotateX(v, state.rotationX);
        point = rotateY(point, state.rotationY);
        point = rotateZ(point, state.rotationZ);
        return point;
      });

      const projectedVertices = rotatedVertices.map(v => project(v, centerX, centerY));

      eyeMesh.edges.forEach(([i, j]) => {
        const [x1, y1, z1] = projectedVertices[i];
        const [x2, y2, z2] = projectedVertices[j];
        const avgZ = (z1 + z2) / 2;
        const opacity = 0.3 + (avgZ / 200) * 0.7;
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      });

      projectedVertices.forEach(([x, y, z]) => {
        const opacity = 0.4 + (z / 200) * 0.6;
        const size = 2 + (z / 200) * 2;
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawColorPalette() {
      const colors = ['#0ff', '#00ffaa', '#00aaff', '#0088ff', '#0066ff'];
      const paletteY = 280;
      const spacing = 45;
      const startX = 300 - (colors.length * spacing) / 2 + spacing / 2;

      colors.forEach((color, i) => {
        const x = startX + i * spacing;
        const wave = Math.sin(state.palettePhase + i * 0.5) * 3;
        const y = paletteY + wave;

        ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
        ctx.fillRect(x - 16, y - 16 + 4, 32, 32);
        ctx.fillStyle = color;
        ctx.fillRect(x - 15, y - 15, 30, 30);

        const borderAlpha = 0.4 + Math.sin(state.palettePhase + i * 0.5) * 0.2;
        ctx.strokeStyle = `rgba(0, 255, 255, ${borderAlpha})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 15, y - 15, 30, 30);
        ctx.shadowBlur = 10 + wave * 2;
        ctx.shadowColor = color;
        ctx.strokeRect(x - 15, y - 15, 30, 30);
        ctx.shadowBlur = 0;
      });
    }

    function drawToolIcons() {
      const iconY = 330;
      const iconSpacing = 40;
      const startX = 300 - iconSpacing;

      ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(startX - 6, iconY + 6);
      ctx.lineTo(startX, iconY);
      ctx.lineTo(startX + 6, iconY + 6);
      ctx.lineTo(startX + 8, iconY - 8);
      ctx.lineTo(startX - 8, iconY + 8);
      ctx.closePath();
      ctx.stroke();

      const brushX = startX + iconSpacing;
      ctx.beginPath();
      ctx.moveTo(brushX, iconY - 8);
      ctx.lineTo(brushX, iconY + 4);
      ctx.moveTo(brushX - 6, iconY);
      ctx.lineTo(brushX + 6, iconY);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(brushX, iconY + 8, 3, 0, Math.PI * 2);
      ctx.stroke();

      const shapeX = startX + iconSpacing * 2;
      ctx.strokeRect(shapeX - 6, iconY - 6, 12, 12);
      ctx.beginPath();
      ctx.arc(shapeX, iconY, 4, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawText() {
      ctx.font = '700 32px "Share Tech Mono", monospace';
      ctx.fillStyle = 'rgba(0, 255, 255, 0.95)';
      ctx.textAlign = 'center';
      ctx.shadowBlur = 12;
      ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
      ctx.fillText('GRAFICHE', 300, 240);

      ctx.font = '400 13px "Share Tech Mono", monospace';
      ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
      ctx.shadowBlur = 6;
      ctx.shadowColor = 'rgba(0, 255, 255, 0.3)';
      ctx.fillText('Design grafico e visual identity', 300, 260);
      ctx.shadowBlur = 0;
    }

    let lastTime = performance.now();

    function animate(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      state.time += deltaTime;
      state.rotationY = state.time * 0.4;
      state.rotationX = Math.sin(state.time * 0.3) * 0.3;
      state.rotationZ = Math.sin(state.time * 0.5) * 0.1;
      state.palettePhase += deltaTime * 2;
      state.gridPhase += deltaTime * 0.8;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, 600, 400);

      drawHexGrid();
      drawWireframeEye();
      drawText();
      drawColorPalette();
      drawToolIcons();

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  </script>
</body>
</html>
